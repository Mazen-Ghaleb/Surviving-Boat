<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - lightning strike</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>

	<div id="container" class="output"></div>


	<script type="module">

		import * as THREE from '../build/three.module.js';

		import { OrbitControls } from './jsm/controls/OrbitControls.js';
		import { LightningStrike } from './jsm/geometries/LightningStrike.js';
		import { LightningStorm } from './jsm/objects/LightningStorm.js';
		import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
		import { RenderPass } from './jsm/postprocessing/RenderPass.js';
		import { OutlinePass } from './jsm/postprocessing/OutlinePass.js';

		let container, stats;

		let scene, renderer, composer;

		let currentSceneIndex = 0;

		let currentTime = 0;

		const sceneCreators = [
			createStormScene
		];

		const clock = new THREE.Clock();

		const raycaster = new THREE.Raycaster();
		const mouse = new THREE.Vector2();

		// ------------ Music Init --------- //

	
		
		window.addEventListener('load', () => {
				// noinspection JSUnresolvedVariable
				let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
				let xhr = new XMLHttpRequest();
				xhr.open('GET', 'soundeffects/thunder.mp3');
				xhr.responseType = 'arraybuffer';
				xhr.addEventListener('load', () => {
					let playsound = (audioBuffer) => {
						let source = audioCtx.createBufferSource();
						source.buffer = audioBuffer;
						source.connect(audioCtx.destination);
						source.loop = false;
						source.start();

						setTimeout(function () {

							playsound(audioBuffer);
						}, 1000 + Math.random()*2500);
					};

					audioCtx.decodeAudioData(xhr.response).then(playsound);
				});
				xhr.send();
			});

			window.addEventListener('load', () => {
				// noinspection JSUnresolvedVariable
				let audioCtx2 = new (window.AudioContext || window.webkitAudioContext)();
				let xhr2 = new XMLHttpRequest();
				xhr2.open('GET', 'soundeffects/waves.mp3');
				xhr2.responseType = 'arraybuffer';
				xhr2.addEventListener('load', () => {
					let playsound2 = (audioBuffer) => {
						let source2 = audioCtx2.createBufferSource();
						source2.buffer = audioBuffer;
						source2.connect(audioCtx2.destination);
						source2.loop = false;
						source2.start();

						setTimeout(function () {

							playsound2(audioBuffer);
						}, 1000 + Math.random()*2500);
					};

					audioCtx2.decodeAudioData(xhr2.response).then(playsound2);
				});
				xhr2.send();
			});

			window.addEventListener('load', () => {
				// noinspection JSUnresolvedVariable
				let audioCtx3 = new (window.AudioContext || window.webkitAudioContext)();
				let xhr3 = new XMLHttpRequest();
				xhr3.open('GET', 'soundeffects/wind.wav');
				xhr3.responseType = 'arraybuffer';
				xhr3.addEventListener('load', () => {
					let playsound3 = (audioBuffer) => {
						let source3 = audioCtx3.createBufferSource();
						source3.buffer = audioBuffer;
						source3.connect(audioCtx3.destination);
						source3.loop = false;
						source3.start();

						setTimeout(function () {

							playsound3(audioBuffer);
						}, 1000 + Math.random()*2500);
					};

					audioCtx3.decodeAudioData(xhr3.response).then(playsound3);
				});
				xhr3.send();
			});



		init();
		animate();

		function init() {

			container = document.getElementById('container');

			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.outputEncoding = THREE.sRGBEncoding;

			container.appendChild(renderer.domElement);

			composer = new EffectComposer(renderer);



			window.addEventListener('resize', onWindowResize);

			createScene();

		}

		function createScene() {

			scene = sceneCreators[currentSceneIndex]();

			scene.userData.timeRate = 1;

		}

		function onWindowResize() {

			scene.userData.camera.aspect = window.innerWidth / window.innerHeight;
			scene.userData.camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

			composer.setSize(window.innerWidth, window.innerHeight);

		}

		//


		//

		function animate() {

			requestAnimationFrame(animate);

			render();


		}

		function render() {

			currentTime += scene.userData.timeRate * clock.getDelta();

			if (currentTime < 0) {

				currentTime = 0;


			}

			scene.userData.render(currentTime);

		}



		//




		//

		function createStormScene() {

			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0x050505);

			scene.userData.canGoBackwardsInTime = false;

			scene.userData.camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 20, 10000);

			// Lights

			scene.add(new THREE.AmbientLight(0x444444));

			const light1 = new THREE.DirectionalLight(0xffffff, 0.5);
			light1.position.set(1, 1, 1);
			scene.add(light1);

			const posLight = new THREE.PointLight(0x00ffff);
			posLight.position.set(0, 100, 0);
			scene.add(posLight);

			// Ground

			const GROUND_SIZE = 1000;

			scene.userData.camera.position.set(0, 0.2, 1.6).multiplyScalar(GROUND_SIZE * 0.5);

			//const ground = new THREE.Mesh( new THREE.PlaneGeometry( GROUND_SIZE, GROUND_SIZE ), new THREE.MeshLambertMaterial( { color: 0x072302 } ) );
			//ground.rotation.x = - Math.PI * 0.5;
			//scene.add( ground );

			// Storm

			scene.userData.lightningColor = new THREE.Color(0xB0FFFF);
			scene.userData.outlineColor = new THREE.Color(0x00FFFF);

			scene.userData.lightningMaterial = new THREE.MeshBasicMaterial({ color: scene.userData.lightningColor });

			const rayDirection = new THREE.Vector3(0, - 1, 0);
			let rayLength = 0;
			const vec1 = new THREE.Vector3();
			const vec2 = new THREE.Vector3();

			scene.userData.rayParams = {

				radius0: 1,
				radius1: 0.5,
				minRadius: 0.3,
				maxIterations: 7,

				timeScale: 0.15,
				propagationTimeFactor: 0.2,
				vanishingTimeFactor: 0.9,
				subrayPeriod: 4,
				subrayDutyCycle: 0.6,

				maxSubrayRecursion: 3,
				ramification: 3,
				recursionProbability: 0.4,

				roughness: 0.85,
				straightness: 0.65,

				onSubrayCreation: function (segment, parentSubray, childSubray, lightningStrike) {

					lightningStrike.subrayConePosition(segment, parentSubray, childSubray, 0.6, 0.6, 0.5);

					// Plane projection

					rayLength = lightningStrike.rayParameters.sourceOffset.y;
					vec1.subVectors(childSubray.pos1, lightningStrike.rayParameters.sourceOffset);
					const proj = rayDirection.dot(vec1);
					vec2.copy(rayDirection).multiplyScalar(proj);
					vec1.sub(vec2);
					const scale = proj / rayLength > 0.5 ? rayLength / proj : 1;
					vec2.multiplyScalar(scale);
					vec1.add(vec2);
					childSubray.pos1.addVectors(vec1, lightningStrike.rayParameters.sourceOffset);

				}

			};

			// Black star mark
			const starVertices = [];
			const prevPoint = new THREE.Vector3(0, 0, 1);
			const currPoint = new THREE.Vector3();
			for (let i = 1; i <= 16; i++) {

				currPoint.set(Math.sin(2 * Math.PI * i / 16), 0, Math.cos(2 * Math.PI * i / 16));

				if (i % 2 === 1) {

					currPoint.multiplyScalar(0.3);

				}

				starVertices.push(0, 0, 0);
				starVertices.push(prevPoint.x, prevPoint.y, prevPoint.z);
				starVertices.push(currPoint.x, currPoint.y, currPoint.z);

				prevPoint.copy(currPoint);

			}

			const starGeometry = new THREE.BufferGeometry();
			starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
			const starMesh = new THREE.Mesh(starGeometry, new THREE.MeshBasicMaterial({ color: 0x020900 }));
			starMesh.scale.multiplyScalar(6);

			//

			const storm = new LightningStorm({

				size: GROUND_SIZE,
				minHeight: 90,
				maxHeight: 200,
				maxSlope: 0.6,
				maxLightnings: 8,

				lightningParameters: scene.userData.rayParams,

				lightningMaterial: scene.userData.lightningMaterial,

				onLightningDown: function (lightning) {

					// Add black star mark at ray strike
					const star1 = starMesh.clone();
					star1.position.copy(lightning.rayParameters.destOffset);
					star1.position.y = 0.05;
					star1.rotation.y = 2 * Math.PI * Math.random();
					scene.add(star1);

				}

			});

			scene.add(storm);

			// Compose rendering

			composer.passes = [];
			composer.addPass(new RenderPass(scene, scene.userData.camera));
			//	createOutline( scene, storm.lightningsMeshes, scene.userData.outlineColor );

			// Controls

			const controls = new OrbitControls(scene.userData.camera, renderer.domElement);
			controls.target.y = GROUND_SIZE * 0.05;
			controls.enableDamping = true;
			controls.dampingFactor = 0.05;

			scene.userData.render = function (time) {

				storm.update(time);

				controls.update();

				if (scene.userData.outlineEnabled) {

					composer.render();

				} else {

					renderer.render(scene, scene.userData.camera);

				}

			};

			return scene;

		}

	</script>

</body>

</html>
